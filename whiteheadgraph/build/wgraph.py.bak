import copy
import word
import networkx as nx
import orderedmultigraph as omg
import whiteheadreduce as wreduce



def simplifyWordlist(wl1,wl2=[],withmap=False):
    """
    Find cyclically reduced roots of words in wl1 that are needed to generate distinct conjugacy classes of maximal cyclic subgroups not already generated by wl2.
    """
    alreadyhave=[word.word([])]*len(wl1)
    alreadyhave.extend([word.maxRoot(w,uptoconjugacy=True) for w in wl2])
    candidates=[word.maxRoot(w,uptoconjugacy=True) for w in wl1]
    need=[]
    wordmap=[None]*len(wl1)
    wordindex=0
    while candidates:
        nextword=candidates.pop(0)
        extraneous, imageindex = word.isConjugateInto(nextword,*alreadyhave,withindex=True)
        if  not extraneous:
            need.append(nextword)
            alreadyhave[wordindex]=nextword
            wordmap[wordindex]=wordindex
        else:
            wordmap[wordindex]=imageindex
        wordindex+=1
    if withmap:
        return need, wordmap
    else:
        return need

def areEquivalentWordlists(wl1,wl2):
    """
    Decide if given wordlists generate same conjugacy classes of maximal cyclic subgroups.
    """
    return not bool(simplifyWordlist(wl1,wl2)) and not bool(simplifyWordlist(wl2,wl1))
    

class WGraph(omg.OrderedMultiGraph):
    """ 
    Thw Whitehead Graph is an omg.OrderedMultiGraph constructed from a list of word.word together with a dictionary of splicing maps splicemaps={vert:splicemap for splicing vert to -vert,...}
    """
   
    def __init__(self, originalwordlist, rank=None, autominimize=False):
        omg.OrderedMultiGraph.__init__(self)
        self.splicemaps={}
        if autominimize:
            self.wordlist=wreduce.WhiteheadMinimize(originalwordlist)['wordlist']
        else:
            self.wordlist=simplifyWordlist(originalwordlist)
        
        
        self.rank=rank if rank!=None else word.guessRank(*originalwordlist)
                    
        for i in set(range(-self.rank,self.rank+1))-set([0]):
            self.addVertex(i)
            self.splicemaps[i]=[]
            
        edgecounter=0
       
        for w in self.wordlist:            
            if len(w)>0:
                firstplace=len(self.splicemaps[-w.letters[0]])
                self.splicemaps[-w.letters[0]]+=[None]
                if len(w)>1:
                    for i in range(1,len(w)):
                        self.addEdge(-w.letters[i-1],w.letters[i],'e'+str(edgecounter))
                        edgecounter+=1
                        self.splicemaps[w.letters[i]]+=[len(self.splicemaps[-w.letters[i]])]
                        self.splicemaps[-w.letters[i]]+=[len(self.splicemaps[w.letters[i]])-1]
                self.addEdge(-w.letters[-1],w.letters[0],'e'+str(edgecounter))
                edgecounter+=1
                self.splicemaps[w.letters[0]]+=[firstplace]
                self.splicemaps[-w.letters[0]][firstplace]=len(self.splicemaps[w.letters[0]])-1

    def inv(self,vert):
        return -vert

    def nextEdge(self,edge,vert):
        return self.edgeOrder(self.inv(vert))[self.splicemaps[vert][self.edgeOrder(vert).index(edge)]]
            
    def getWordlist(self):
        """
        return a wordlist generating this Whitehead graph
        """
        traversed=set()
        wordlist=[]
        while traversed!=set(self.edgekeys):
            firstedge=(set(self.edgekeys)-traversed).pop()
            firstvert=self.origin(firstedge)
            nextvert=self.oppositeEnd(firstedge,firstvert)
            currentword=[nextvert]
            traversed.add(firstedge)
            nextedge=self.nextEdge(firstedge,nextvert) 
            while nextedge!=firstedge:
                nextvert=self.oppositeEnd(nextedge,-nextvert)
                currentword.append(nextvert)
                traversed.add(nextedge)
                nextedge=self.nextEdge(nextedge, nextvert)
            wordlist.append(word.word(currentword))
        return wordlist

    def __copy__(self):
        return WGraph(self.wordlist,self.rank)

def wgrowOne(G,W,vert):
    """
    Extend generalized Whitehead graph G by splicing on Whitehead graph W at vertex vert.
    """
    assert(vert in G)
    assert(type(vert)==tuple)
    prefix = vert
    Gsplicevert= vert
    Wsplicevert= -vert[-1]
    return omg.splice(G,W,Gsplicevert,Wsplicevert,W.splicemaps[vert[-1]],(),prefix)

def wgrowWord(W,w):
    """
    Returns generalized Whitehead graph over the segment w
    """
    Gedges=[((edge[0],), (edge[1],), (edge[2],), edge[3]) for edge in W.edges_iter(keys=True, data=True)]
    Gedgeorders=dict(((vert,),[(edge,) for edge in W.node[vert]['edgeorder']]) for vert in W.nodes_iter())  #{(vert,):[(edge,) for edge in W.node[vert]['edgeorder']] for vert in W.nodes_iter()}
    G=omg.OrderedMultiGraph(Gedges,Gedgeorders)
    for vert in W.nodes_iter(): # We have missed isolated vertices. Add them back.
        if W.valence(vert)==0:
            G.addVertex((vert,))
    # G is a deep copy of W so that vertex and edge names are all length 1 tuples
    if len(w)>0:
        prefix=()
        for i in range(len(w)):
            prefix+=(w.letters[i],)
            G=wgrowOne(G,W,prefix)
    return G



def wgparse(wgraphorwordlist):
    """
    Take as input either a whiteheadgraph or wordlist and return a whitehead graph and wordlist.
    Note that if wgraphorwordlist is a wordlist then WGraph(wgraphorwordlist).wordlist=simplifyWordlist(wgraphorwordlist).
    """
    try:
        return wgraphorwordlist, wgraphorwordlist.wordlist
    except AttributeError:
        return WGraph(wgraphorwordlist), wgraphorwordlist
        
    
    
